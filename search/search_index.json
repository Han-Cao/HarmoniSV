{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HarmoniSV A toolkit to harmonize and filter structural variations across methods and samples. Last updated: 2024-01-16 Features Harmonize SVs discovered by different SV calling methods Filter high-confidence SVs with a random forest classifier Fast VCF manipulation, annotation, and conversion Important The documentation for below commands are ready now: harmonize-header harmonize represent genotype For other commands, please type harmonisv <command> -h to get help. I am simplifying the input format and command line options for other commands. The documentation will be updated after that.","title":"Introduction"},{"location":"#harmonisv","text":"A toolkit to harmonize and filter structural variations across methods and samples. Last updated: 2024-01-16","title":"HarmoniSV"},{"location":"#features","text":"Harmonize SVs discovered by different SV calling methods Filter high-confidence SVs with a random forest classifier Fast VCF manipulation, annotation, and conversion","title":"Features"},{"location":"#important","text":"The documentation for below commands are ready now: harmonize-header harmonize represent genotype For other commands, please type harmonisv <command> -h to get help. I am simplifying the input format and command line options for other commands. The documentation will be updated after that.","title":"Important"},{"location":"command_list/","text":"Commands list Last updated: 2024-01-16 VCF manipulation harmonize-header Harmonize VCF headers harmonize Harmonize SV VCFs across samples and SV calling methods sample2pop Convert single-sample VCF to multi-sample VCF intersect Intersect SVs with genomic features SV analysis represent Select the representative SV from merged SVs genotype Genotype SVs across SV genotyping methods filter Random forest filter for SVs concordance Calculate genotype concordance between two VCFs","title":"Command list"},{"location":"command_list/#commands-list","text":"Last updated: 2024-01-16 VCF manipulation harmonize-header Harmonize VCF headers harmonize Harmonize SV VCFs across samples and SV calling methods sample2pop Convert single-sample VCF to multi-sample VCF intersect Intersect SVs with genomic features SV analysis represent Select the representative SV from merged SVs genotype Genotype SVs across SV genotyping methods filter Random forest filter for SVs concordance Calculate genotype concordance between two VCFs","title":"Commands list"},{"location":"quick_start/","text":"Quick start Last updated: 2023-03-19 Installation git clone https://github.com/Han-Cao/HarmoniSV.git cd HarmoniSV/src/harmoniSV chmod +x harmonisv Dependencies HarmoniSV is written in python3.8. The following python modules are required: pysam pandas numpy matplotlib scikit-learn pyranges Usage Go to the src/harmoniSV directory and run harmonisv : ./harmonisv HarmoniSV: A toolkit to harmonize and filter structural variantions across methods and samples Version: 0.1.0 Usage: harmonisv <command> [options] Commands: -- VCF manipulation harmonize Harmonize SV VCFs from across samples and SV calling methods harmonize-header Harmonize VCF headers sample2pop Convert single-sample VCF to multi-sample VCF intersect Intersect SVs with genomic features -- Analysis on SV callset represent Select the representative SV from merged SVs genotype Genotype SVs across SV genotyping methods filter Random forest filter for SVs concordance Calculate genotype concordance between two VCFs Note: 1. All input VCFs MUST follow the VCF specification 2. HarmoniSV assume specific variant ID format to index SVs from different methods and samples, please check the required ID format of different commands before you use 3. The input/output VCF format (i.e., vcf, vcf.gz, bcf) will be automatically detected For help on a specific command, run: harmonisv <command> -h","title":"Quick start"},{"location":"quick_start/#quick-start","text":"Last updated: 2023-03-19","title":"Quick start"},{"location":"quick_start/#installation","text":"git clone https://github.com/Han-Cao/HarmoniSV.git cd HarmoniSV/src/harmoniSV chmod +x harmonisv","title":"Installation"},{"location":"quick_start/#dependencies","text":"HarmoniSV is written in python3.8. The following python modules are required: pysam pandas numpy matplotlib scikit-learn pyranges","title":"Dependencies"},{"location":"quick_start/#usage","text":"Go to the src/harmoniSV directory and run harmonisv : ./harmonisv HarmoniSV: A toolkit to harmonize and filter structural variantions across methods and samples Version: 0.1.0 Usage: harmonisv <command> [options] Commands: -- VCF manipulation harmonize Harmonize SV VCFs from across samples and SV calling methods harmonize-header Harmonize VCF headers sample2pop Convert single-sample VCF to multi-sample VCF intersect Intersect SVs with genomic features -- Analysis on SV callset represent Select the representative SV from merged SVs genotype Genotype SVs across SV genotyping methods filter Random forest filter for SVs concordance Calculate genotype concordance between two VCFs Note: 1. All input VCFs MUST follow the VCF specification 2. HarmoniSV assume specific variant ID format to index SVs from different methods and samples, please check the required ID format of different commands before you use 3. The input/output VCF format (i.e., vcf, vcf.gz, bcf) will be automatically detected For help on a specific command, run: harmonisv <command> -h","title":"Usage"},{"location":"tutorial/","text":"Tutorial Last updated: 2024-01-16 This tutorial provides a step-by-step guide on how to utilize harmonisv for post-processing the outcomes of various SV calling methods and conducting joint SV calling across multiple samples and methods. The necessary input data and scripts for this tutorial can be found in the test folder on GitHub. 1. SV Discovery Using Various Methods Please note that harmonisv itself does not directly perform SV calling. Instead, it is designed to harmonize and integrate the results from any SV calling methods that generate a VCF file following the VCF specification and contains the essential information: Type of SV Length of SV Sequencing depth for both reference and alternative alleles In this tutorial, we employ two aligners, minimap2 and NGMLR, and three SV callers, cuteSV, sniffles, and SVIM, to call SVs in the HG002 sample. Align long-read sequencing data to reference: ref=\"hs37d5.fa\" input=\"HG002.fasta\" # minimap2 minimap2 -L -t 36 --MD -a -x map-pb $ref $input | samtools sort -@ 4 -o $bam # NGMLR ngmlr --bam-fix -t 40 -x pacbio \\ -r $ref \\ -q $input \\ -o $bam Call SVs from alignments: # sniffles (ver 2.0.6) sniffles \\ -i $bam \\ -v $vcf \\ --reference $ref \\ --tandem-repeats \"human_hs37d5.trf.bed\" # SVIM (ver 2.0.0) svim alignment $outpath $input $ref \\ --max_sv_size 1000000 # cuteSV (ver 2.0.3) cuteSV \\ --max_cluster_bias_INS 100 \\ --diff_ratio_merging_INS 0.3 \\ --max_cluster_bias_DEL 200 \\ --diff_ratio_merging_DEL 0.5 \\ --genotype \\ $input $ref $vcf $workdir After running the above commands, we get the following VCF files: HG002.minimap2.sniffles.vcf HG002.minimap2.svim.vcf HG002.minimap2.cuteSV.vcf HG002.NGMLR.sniffles.vcf HG002.NGMLR.svim.vcf HG002.NGMLR.cuteSV.vcf 2. Harmonize VCFs The output VCF files from different SV calling methods usually have different formats in their INFO and FORMAT fields. To integrate the results from different methods, we first need to harmonize the VCFs to a standard format. This is because when we rename or move VCF tags (e.g., FORMAT/tag to INFO/tag), the newly added tags should also have definition in the header according to the VCF specification. Here, we first use harmonize-header to combine the headers from all input VCFs. # If one tag is defined in multiple VCFs # the one from the reference VCF or the first VCF in the list will be used harmonisv harmonize-header \\ -f vcf_list.txt \\ # read VCF list from file -o harmonized_header.txt \\ # output file -r HG002.minimap2.sniffles.vcf # reference VCF file (optional) Then, we can use harmonize to standardize the VCFs: reheader with harmonized_header.txt for the same information stored in different tags, rename them to the same tag normalize SV types to the same format (e.g., DUP:TANDEM to DUP ) extract all required tags to INFO field rename SV ID to make them unique across samples and methods # sniffles harmonisv harmonize \\ -i HG002.minimap2.sniffles.vcf \\ -o HG002.minimap2.sniffles.harmonized.vcf \\ --info SVTYPE,SVLEN,END,STRANDS=STRAND \\ # INFO tags to be kept --format-to-info RE=DV \\ # extract FORMAT/DV to INFO/RE --format-to-info-sum DP=DR,DP=DV \\ # INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.sniffles \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number # SVIM harmonisv harmonize \\ -i HG002.minimap2.svim.vcf \\ -o HG002.minimap2.svim.harmonized.vcf \\ --info SVTYPE,SVLEN,END,RE=SUPPORT \\ # INFO tags to be kept --format-to-info DP=DP \\ # extract FORMAT/DP to INFO/DP --DUP DUP,DUP:TANDEM,DUP:INT \\ # normalize SV types --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.svim \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number # cuteSV harmonisv harmonize \\ -i HG002.minimap2.cuteSV.vcf \\ -o HG002.minimap2.cuteSV.harmonized.vcf \\ --info SVTYPE,SVLEN,END,RE \\ # INFO tags to be kept --format-to-info-sum DP=DR,DP=DV \\ # INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.cuteSV \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number 3. Merge VCFs Ongoing...","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"Last updated: 2024-01-16 This tutorial provides a step-by-step guide on how to utilize harmonisv for post-processing the outcomes of various SV calling methods and conducting joint SV calling across multiple samples and methods. The necessary input data and scripts for this tutorial can be found in the test folder on GitHub.","title":"Tutorial"},{"location":"tutorial/#1-sv-discovery-using-various-methods","text":"Please note that harmonisv itself does not directly perform SV calling. Instead, it is designed to harmonize and integrate the results from any SV calling methods that generate a VCF file following the VCF specification and contains the essential information: Type of SV Length of SV Sequencing depth for both reference and alternative alleles In this tutorial, we employ two aligners, minimap2 and NGMLR, and three SV callers, cuteSV, sniffles, and SVIM, to call SVs in the HG002 sample. Align long-read sequencing data to reference: ref=\"hs37d5.fa\" input=\"HG002.fasta\" # minimap2 minimap2 -L -t 36 --MD -a -x map-pb $ref $input | samtools sort -@ 4 -o $bam # NGMLR ngmlr --bam-fix -t 40 -x pacbio \\ -r $ref \\ -q $input \\ -o $bam Call SVs from alignments: # sniffles (ver 2.0.6) sniffles \\ -i $bam \\ -v $vcf \\ --reference $ref \\ --tandem-repeats \"human_hs37d5.trf.bed\" # SVIM (ver 2.0.0) svim alignment $outpath $input $ref \\ --max_sv_size 1000000 # cuteSV (ver 2.0.3) cuteSV \\ --max_cluster_bias_INS 100 \\ --diff_ratio_merging_INS 0.3 \\ --max_cluster_bias_DEL 200 \\ --diff_ratio_merging_DEL 0.5 \\ --genotype \\ $input $ref $vcf $workdir After running the above commands, we get the following VCF files: HG002.minimap2.sniffles.vcf HG002.minimap2.svim.vcf HG002.minimap2.cuteSV.vcf HG002.NGMLR.sniffles.vcf HG002.NGMLR.svim.vcf HG002.NGMLR.cuteSV.vcf","title":"1. SV Discovery Using Various Methods"},{"location":"tutorial/#2-harmonize-vcfs","text":"The output VCF files from different SV calling methods usually have different formats in their INFO and FORMAT fields. To integrate the results from different methods, we first need to harmonize the VCFs to a standard format. This is because when we rename or move VCF tags (e.g., FORMAT/tag to INFO/tag), the newly added tags should also have definition in the header according to the VCF specification. Here, we first use harmonize-header to combine the headers from all input VCFs. # If one tag is defined in multiple VCFs # the one from the reference VCF or the first VCF in the list will be used harmonisv harmonize-header \\ -f vcf_list.txt \\ # read VCF list from file -o harmonized_header.txt \\ # output file -r HG002.minimap2.sniffles.vcf # reference VCF file (optional) Then, we can use harmonize to standardize the VCFs: reheader with harmonized_header.txt for the same information stored in different tags, rename them to the same tag normalize SV types to the same format (e.g., DUP:TANDEM to DUP ) extract all required tags to INFO field rename SV ID to make them unique across samples and methods # sniffles harmonisv harmonize \\ -i HG002.minimap2.sniffles.vcf \\ -o HG002.minimap2.sniffles.harmonized.vcf \\ --info SVTYPE,SVLEN,END,STRANDS=STRAND \\ # INFO tags to be kept --format-to-info RE=DV \\ # extract FORMAT/DV to INFO/RE --format-to-info-sum DP=DR,DP=DV \\ # INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.sniffles \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number # SVIM harmonisv harmonize \\ -i HG002.minimap2.svim.vcf \\ -o HG002.minimap2.svim.harmonized.vcf \\ --info SVTYPE,SVLEN,END,RE=SUPPORT \\ # INFO tags to be kept --format-to-info DP=DP \\ # extract FORMAT/DP to INFO/DP --DUP DUP,DUP:TANDEM,DUP:INT \\ # normalize SV types --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.svim \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number # cuteSV harmonisv harmonize \\ -i HG002.minimap2.cuteSV.vcf \\ -o HG002.minimap2.cuteSV.harmonized.vcf \\ --info SVTYPE,SVLEN,END,RE \\ # INFO tags to be kept --format-to-info-sum DP=DR,DP=DV \\ # INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # reheader --id-prefix HG002.minimap2.cuteSV \\ # add sample ID and method as prefix to SV ID --rename-id # rename SV ID to prefix.chr.svtype.number","title":"2. Harmonize VCFs"},{"location":"tutorial/#3-merge-vcfs","text":"Ongoing...","title":"3. Merge VCFs"},{"location":"vcf_format/","text":"VCF format Last updated: 2023-12-08 Requirements bi-allelic VCF/BCF files following the VCF specification single-sample VCF/BCF files are suggested as input for SV calling workflow. Although multi-sample VCFs may not raise errors (except for genotype ), they are not fully tested and may cause unexpected results. The input/output VCF format (i.e., vcf, vcf.gz, bcf) will be automatically detected. However, a temporary uncompressed VCF file will be generated if the output is vcf.gz or bcf Variant ID Unique variant IDs are used to index variants in the SV calling workflow. To generate a unique ID, use harmonize command. For example, harmonize --rename-id --id-prefix HG002.minimap2.sniffles will generate unique IDs like HG002.minimap2.sniffles.INS.1 . INFO tags The following INFO tags could be used or generated in the SV calling workflow. Not all listed INFO tags are required for all commands. Please refer to the documentation of each command for more details. INFO tags generated by upstream SV callers: SVTYPE : SV types defined in the VCF specification SVLEN : SV length defined in the VCF specification AC : allele count of alternate alleles DP : sequencing depth of the SV RE : number of reads supporting the SV INFO tags generated by harmonisv : represent command: REPRESENT_SV : original ID that selected as the representative SV ID_LIST : list of SVs merged to the representative SV genotype command: VAF : variant allele fraction (VAF = RE / DP) SUPP_METHOD : number of methods support the SV (method = aligner + caller) SUPP_METHOD_FORCE : number of force calling methods support the SV SUPP_CALLER : number of callers support the SV, it counts maximum number of callers using the same aligner, e.g., if minimap2 + sniffles , minimap2 + svim and NGMLR + cuteSV support the SV, SUPP_CALLER=2 . SUPP_CALLER_FORCE : number of force calling callers support the SV MEAN_VAF : average VAF of all methods STD_VAF : standard deviation of VAF of all methods MEAN_VAF_CALL : average VAF of methods support the SV (VAF > threshold) STD_VAF_CALL : standard deviation of VAF of methods support the SV MAX_RE : maximum number of reads support the SV TAG_ALIGNER_CALLER : the INFO/TAG value obtained from individual methods, e.g., VAF_MINIMAP2_SNIFFLES is the VAF value of SV called using the method minimap2 + sniffles . filter command: RF_SCORE : random forest quality scoreo of the SV (ranged from 0 to 1)","title":"VCF format"},{"location":"vcf_format/#vcf-format","text":"Last updated: 2023-12-08","title":"VCF format"},{"location":"vcf_format/#requirements","text":"bi-allelic VCF/BCF files following the VCF specification single-sample VCF/BCF files are suggested as input for SV calling workflow. Although multi-sample VCFs may not raise errors (except for genotype ), they are not fully tested and may cause unexpected results. The input/output VCF format (i.e., vcf, vcf.gz, bcf) will be automatically detected. However, a temporary uncompressed VCF file will be generated if the output is vcf.gz or bcf","title":"Requirements"},{"location":"vcf_format/#variant-id","text":"Unique variant IDs are used to index variants in the SV calling workflow. To generate a unique ID, use harmonize command. For example, harmonize --rename-id --id-prefix HG002.minimap2.sniffles will generate unique IDs like HG002.minimap2.sniffles.INS.1 .","title":"Variant ID"},{"location":"vcf_format/#info-tags","text":"The following INFO tags could be used or generated in the SV calling workflow. Not all listed INFO tags are required for all commands. Please refer to the documentation of each command for more details. INFO tags generated by upstream SV callers: SVTYPE : SV types defined in the VCF specification SVLEN : SV length defined in the VCF specification AC : allele count of alternate alleles DP : sequencing depth of the SV RE : number of reads supporting the SV INFO tags generated by harmonisv : represent command: REPRESENT_SV : original ID that selected as the representative SV ID_LIST : list of SVs merged to the representative SV genotype command: VAF : variant allele fraction (VAF = RE / DP) SUPP_METHOD : number of methods support the SV (method = aligner + caller) SUPP_METHOD_FORCE : number of force calling methods support the SV SUPP_CALLER : number of callers support the SV, it counts maximum number of callers using the same aligner, e.g., if minimap2 + sniffles , minimap2 + svim and NGMLR + cuteSV support the SV, SUPP_CALLER=2 . SUPP_CALLER_FORCE : number of force calling callers support the SV MEAN_VAF : average VAF of all methods STD_VAF : standard deviation of VAF of all methods MEAN_VAF_CALL : average VAF of methods support the SV (VAF > threshold) STD_VAF_CALL : standard deviation of VAF of methods support the SV MAX_RE : maximum number of reads support the SV TAG_ALIGNER_CALLER : the INFO/TAG value obtained from individual methods, e.g., VAF_MINIMAP2_SNIFFLES is the VAF value of SV called using the method minimap2 + sniffles . filter command: RF_SCORE : random forest quality scoreo of the SV (ranged from 0 to 1)","title":"INFO tags"},{"location":"SV_analysis/filter/","text":"filter Random forest filter for SVs Last updated: 2023-12-08 TODO","title":"filter"},{"location":"SV_analysis/filter/#filter","text":"Random forest filter for SVs Last updated: 2023-12-08 TODO","title":"filter"},{"location":"SV_analysis/genotype/","text":"genotype Genotype SVs across SV genotyping methods Last updated: 2023-01-16 Input requirmenets Manifest : Format : tab-separated file with header. Columns : file : path to SV discovery and force calling VCF/BCF file sample : sample ID aligner : aligner used to generate the SV call set caller : SV caller used to generate the SV call set if_force_call : whether the SV call set is generated by force-calling (1: True, 0: False) info (optional): INFO tags in additional to DP , RE to be added to the output VCF Representative VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , SVLEN , ID_LIST ID : unique ID within the representative VCF Discovery calling VCF : Format : single-sample, bi-allelic VCF/BCF files following the VCF specification ID : unique ID listed in the ID_LIST of the representative VCF INFO : DP , RE Force calling VCF : Format : single-sample, bi-allelic VCF/BCF files following the VCF specification ID : the same ID as the representative VCF INFO : DP , RE Region : Format : region string accepted by bcftools (e.g., chr1[:100-200] ) Output VCF : single-sample genotyped VCF/BCF files. ID : the same ID as the representative VCF Usage harmonisv represent [options] -i <input_vcf> -f <manifest> -o <output_vcf> --sample <id> Genotyping methods The genotype command integrates information from various SV discovery and force calling methods to genotype SVs with high sensitivity. The genotype of an SV is determined through the following steps: Extract DP , RE and additional INFO tags from SV calling VCFs and calculate VAF . If a method performs both discovery calling and force calling, the results of force calling will be used. If one method's VAF > heterozygous frequency threshold, it is considered to support the SV and counted in SUPP_METHOD . The maximum number of SV callers using the same aligner is recorded in SUPP_CALLER . For example, if an SV is supported by callers sniffles and cuteSV with aligner minimap2 , as well as caller svim with aligner NGMLR , then SUPP_CALLER would be set to 2. Calculate the average VAF of methods that support the SV ( MEAN_VAF_CALL ) and determine the genotype as follows: 0/1 if the heterozygous frequency threshold <= MEAN_VAF_CALL < homozygous frequency threshold 1/1 if MEAN_VAF_CALL >= homozygous frequency threshold If no method supports the SV, determine the genotype as: 0/0 if DP >= minimum depth threshold ./. if DP < minimum depth threshold The methods used to calculate MEAN_VAF_CALL can be specified by --include option. If --include all is used, all methods will be included. If --include force_call is used, only force calling methods will be included. Alternatively, a comma-separated list of methods in the format of ALIGNER_CALLER can be specified (e.g., --include MINIMAP2_SNIFFLES ). The genotyping results are highly sensitive as they retain SVs supported by any method. To obtain high-confidence SVs, consider further filtering the results: filter : filter SVs by training a random forest model consensus calling: filter SVs by the number of supporting methods, e.g., bcftools view -i 'SUPP_CALLER >= 2' Examples In this example, we genotype HG002 using the discovery calling and force calling results from the combinations of 2 aligners (minimap2 and NGMLR) and 3 SV callers (sniffles, cuteSV, and svim). harmonisv genotype \\ -i representative.vcf \\ -f manifest.txt \\ -o HG002.representative.genotyped.vcf \\ --sample HG002 The manifest file manifest.txt is shown below: file sample aligner caller is_force_call info output/harmonize_force_call/HG002.NGMLR.cuteSV.harmonized.vcf HG002 NGMLR cuteSV 1 PRECISE,CIPOS,CILEN output/harmonize_force_call/HG002.NGMLR.sniffles.harmonized.vcf HG002 NGMLR sniffles 1 output/harmonize_force_call/HG002.minimap2.cuteSV.harmonized.vcf HG002 minimap2 cuteSV 1 PRECISE,CIPOS,CILEN output/harmonize_force_call/HG002.minimap2.sniffles.harmonized.vcf HG002 minimap2 sniffles 1 output/harmonize/HG002.NGMLR.cuteSV.harmonized.vcf HG002 NGMLR cuteSV 0 output/harmonize/HG002.NGMLR.sniffles.harmonized.vcf HG002 NGMLR sniffles 0 output/harmonize/HG002.NGMLR.svim.harmonized.vcf HG002 NGMLR svim 0 output/harmonize/HG002.minimap2.cuteSV.harmonized.vcf HG002 minimap2 cuteSV 0 output/harmonize/HG002.minimap2.sniffles.harmonized.vcf HG002 minimap2 sniffles 0 output/harmonize/HG002.minimap2.svim.harmonized.vcf HG002 minimap2 svim 0 An example output is shown below: 22 16147398 All_method.INS.1 G GCCTCAGCCTCCCAAAAAGTGCTGGAATTATAAGCGTGAGCCACTGTGCCAACCGATTTTTTTGGTATTTTTAGTAAAGATGGGGTTTCATCATCTTGGAACTAGGCTGGTCTTGAACTCCTGATCTCGTGATCCACCCAC . . SVTYPE=INS;END=16147398;SVLEN=140;AC=2;REPRESENT_SV=HG002.NGMLR.svim.INS.1;CIPOS_NGMLR_CUTESV=-14,14;CIPOS_MINIMAP2_CUTESV=-8,8;RE_NGMLR_CUTESV=6;RE_NGMLR_SNIFFLES=6;RE_MINIMAP2_CUTESV=35;RE_MINIMAP2_SNIFFLES=40;RE_MINIMAP2_SVIM=39;RE_NGMLR_SVIM=6;CILEN_NGMLR_CUTESV=-9,9;CILEN_MINIMAP2_CUTESV=-4,4;DP_NGMLR_CUTESV=6;DP_NGMLR_SNIFFLES=6;DP_MINIMAP2_CUTESV=39;DP_MINIMAP2_SNIFFLES=40;DP_MINIMAP2_SVIM=40;DP_NGMLR_SVIM=6;PRECISE_NGMLR_CUTESV;PRECISE_MINIMAP2_CUTESV;VAF_NGMLR_CUTESV=1;VAF_NGMLR_SNIFFLES=1;VAF_MINIMAP2_CUTESV=0.897436;VAF_MINIMAP2_SNIFFLES=1;VAF_MINIMAP2_SVIM=0.975;VAF_NGMLR_SVIM=1;SUPP_METHOD=6;SUPP_METHOD_FORCE=4;SUPP_CALLER=3;SUPP_CALLER_FORCE=2;MAX_RE=40;MEAN_VAF=0.978739;STD_VAF=0.0374884;MEAN_VAF_CALL=0.978739;STD_VAF_CALL=0.0374884 GT:DP:AD 1/1:.:.,. 22 16212542 All_method.DEL.1 CGCTCCAAATATCCACTCGCGGTTTCTGCAAAAAGAGTGTTTCAAAACTTCTCAATCAAAAGAAAGGTTCAACTCTGTGAGATGAATGCACACATCACAAAGAAGTTTCTCAGAATGCTTCTGTCTAGTTTTTATGTGAAGATATTCCCTTTTCCACCACAGGCC C . . SVTYPE=DEL;END=16212706;SVLEN=-164;AC=1;REPRESENT_SV=HG002.minimap2.svim.DEL.2;CIPOS_NGMLR_CUTESV=-4,4;CIPOS_MINIMAP2_CUTESV=-22,22;RE_NGMLR_CUTESV=2;RE_NGMLR_SNIFFLES=2;RE_MINIMAP2_CUTESV=46;RE_MINIMAP2_SNIFFLES=46;RE_MINIMAP2_SVIM=44;RE_NGMLR_SVIM=0;CILEN_NGMLR_CUTESV=-1,1;CILEN_MINIMAP2_CUTESV=-7,7;DP_NGMLR_CUTESV=3;DP_NGMLR_SNIFFLES=6;DP_MINIMAP2_CUTESV=66;DP_MINIMAP2_SNIFFLES=68;DP_MINIMAP2_SVIM=72;DP_NGMLR_SVIM=.;PRECISE_NGMLR_CUTESV;PRECISE_MINIMAP2_CUTESV;VAF_NGMLR_CUTESV=0.666667;VAF_NGMLR_SNIFFLES=0.333333;VAF_MINIMAP2_CUTESV=0.69697;VAF_MINIMAP2_SNIFFLES=0.676471;VAF_MINIMAP2_SVIM=0.611111;VAF_NGMLR_SVIM=0;SUPP_METHOD=5;SUPP_METHOD_FORCE=4;SUPP_CALLER=3;SUPP_CALLER_FORCE=2;MAX_RE=46;MEAN_VAF=0.497425;STD_VAF=0.254231;MEAN_VAF_CALL=0.59691;STD_VAF_CALL=0.13482 GT:DP:AD 0/1:.:.,. Arguments Input/Output arguments: -i, --invcf VCF input representative SV call set VCF/BCF -f, --manifest TSV tab separated manifest file of SV calling results. Column headers should be: file, sample, aligner, caller, is_force_call, info (optional) --sample ID sample to be genotyped, should be listed in the manifest file -o, --outvcf VCF output VCF -r, --region CHR region to genotype (requires indexed VCF) Genotyping arguments: --min-dp 10 minimum depth to to genotype SVs as 0/0 if no method has VAF > --hetero-freq , otherwise ./. (default: 10) --homo-freq 0.8 minimum average variant allele fraction to genotype as homozygous (default: 0.8) --hetero-freq 0.2 minimum average variant allele fraction to genotype as heterozygous (default: 0.2) --include all methods to be included to determine genotype. Options: 'all', 'force_call', or comma-separated list of methods in format of 'ALIGNER_CALLER' (default: 'all')","title":"genotype"},{"location":"SV_analysis/genotype/#genotype","text":"Genotype SVs across SV genotyping methods Last updated: 2023-01-16","title":"genotype"},{"location":"SV_analysis/genotype/#input-requirmenets","text":"Manifest : Format : tab-separated file with header. Columns : file : path to SV discovery and force calling VCF/BCF file sample : sample ID aligner : aligner used to generate the SV call set caller : SV caller used to generate the SV call set if_force_call : whether the SV call set is generated by force-calling (1: True, 0: False) info (optional): INFO tags in additional to DP , RE to be added to the output VCF Representative VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , SVLEN , ID_LIST ID : unique ID within the representative VCF Discovery calling VCF : Format : single-sample, bi-allelic VCF/BCF files following the VCF specification ID : unique ID listed in the ID_LIST of the representative VCF INFO : DP , RE Force calling VCF : Format : single-sample, bi-allelic VCF/BCF files following the VCF specification ID : the same ID as the representative VCF INFO : DP , RE Region : Format : region string accepted by bcftools (e.g., chr1[:100-200] )","title":"Input requirmenets"},{"location":"SV_analysis/genotype/#output","text":"VCF : single-sample genotyped VCF/BCF files. ID : the same ID as the representative VCF","title":"Output"},{"location":"SV_analysis/genotype/#usage","text":"harmonisv represent [options] -i <input_vcf> -f <manifest> -o <output_vcf> --sample <id>","title":"Usage"},{"location":"SV_analysis/genotype/#genotyping-methods","text":"The genotype command integrates information from various SV discovery and force calling methods to genotype SVs with high sensitivity. The genotype of an SV is determined through the following steps: Extract DP , RE and additional INFO tags from SV calling VCFs and calculate VAF . If a method performs both discovery calling and force calling, the results of force calling will be used. If one method's VAF > heterozygous frequency threshold, it is considered to support the SV and counted in SUPP_METHOD . The maximum number of SV callers using the same aligner is recorded in SUPP_CALLER . For example, if an SV is supported by callers sniffles and cuteSV with aligner minimap2 , as well as caller svim with aligner NGMLR , then SUPP_CALLER would be set to 2. Calculate the average VAF of methods that support the SV ( MEAN_VAF_CALL ) and determine the genotype as follows: 0/1 if the heterozygous frequency threshold <= MEAN_VAF_CALL < homozygous frequency threshold 1/1 if MEAN_VAF_CALL >= homozygous frequency threshold If no method supports the SV, determine the genotype as: 0/0 if DP >= minimum depth threshold ./. if DP < minimum depth threshold The methods used to calculate MEAN_VAF_CALL can be specified by --include option. If --include all is used, all methods will be included. If --include force_call is used, only force calling methods will be included. Alternatively, a comma-separated list of methods in the format of ALIGNER_CALLER can be specified (e.g., --include MINIMAP2_SNIFFLES ). The genotyping results are highly sensitive as they retain SVs supported by any method. To obtain high-confidence SVs, consider further filtering the results: filter : filter SVs by training a random forest model consensus calling: filter SVs by the number of supporting methods, e.g., bcftools view -i 'SUPP_CALLER >= 2'","title":"Genotyping methods"},{"location":"SV_analysis/genotype/#examples","text":"In this example, we genotype HG002 using the discovery calling and force calling results from the combinations of 2 aligners (minimap2 and NGMLR) and 3 SV callers (sniffles, cuteSV, and svim). harmonisv genotype \\ -i representative.vcf \\ -f manifest.txt \\ -o HG002.representative.genotyped.vcf \\ --sample HG002 The manifest file manifest.txt is shown below: file sample aligner caller is_force_call info output/harmonize_force_call/HG002.NGMLR.cuteSV.harmonized.vcf HG002 NGMLR cuteSV 1 PRECISE,CIPOS,CILEN output/harmonize_force_call/HG002.NGMLR.sniffles.harmonized.vcf HG002 NGMLR sniffles 1 output/harmonize_force_call/HG002.minimap2.cuteSV.harmonized.vcf HG002 minimap2 cuteSV 1 PRECISE,CIPOS,CILEN output/harmonize_force_call/HG002.minimap2.sniffles.harmonized.vcf HG002 minimap2 sniffles 1 output/harmonize/HG002.NGMLR.cuteSV.harmonized.vcf HG002 NGMLR cuteSV 0 output/harmonize/HG002.NGMLR.sniffles.harmonized.vcf HG002 NGMLR sniffles 0 output/harmonize/HG002.NGMLR.svim.harmonized.vcf HG002 NGMLR svim 0 output/harmonize/HG002.minimap2.cuteSV.harmonized.vcf HG002 minimap2 cuteSV 0 output/harmonize/HG002.minimap2.sniffles.harmonized.vcf HG002 minimap2 sniffles 0 output/harmonize/HG002.minimap2.svim.harmonized.vcf HG002 minimap2 svim 0 An example output is shown below: 22 16147398 All_method.INS.1 G GCCTCAGCCTCCCAAAAAGTGCTGGAATTATAAGCGTGAGCCACTGTGCCAACCGATTTTTTTGGTATTTTTAGTAAAGATGGGGTTTCATCATCTTGGAACTAGGCTGGTCTTGAACTCCTGATCTCGTGATCCACCCAC . . SVTYPE=INS;END=16147398;SVLEN=140;AC=2;REPRESENT_SV=HG002.NGMLR.svim.INS.1;CIPOS_NGMLR_CUTESV=-14,14;CIPOS_MINIMAP2_CUTESV=-8,8;RE_NGMLR_CUTESV=6;RE_NGMLR_SNIFFLES=6;RE_MINIMAP2_CUTESV=35;RE_MINIMAP2_SNIFFLES=40;RE_MINIMAP2_SVIM=39;RE_NGMLR_SVIM=6;CILEN_NGMLR_CUTESV=-9,9;CILEN_MINIMAP2_CUTESV=-4,4;DP_NGMLR_CUTESV=6;DP_NGMLR_SNIFFLES=6;DP_MINIMAP2_CUTESV=39;DP_MINIMAP2_SNIFFLES=40;DP_MINIMAP2_SVIM=40;DP_NGMLR_SVIM=6;PRECISE_NGMLR_CUTESV;PRECISE_MINIMAP2_CUTESV;VAF_NGMLR_CUTESV=1;VAF_NGMLR_SNIFFLES=1;VAF_MINIMAP2_CUTESV=0.897436;VAF_MINIMAP2_SNIFFLES=1;VAF_MINIMAP2_SVIM=0.975;VAF_NGMLR_SVIM=1;SUPP_METHOD=6;SUPP_METHOD_FORCE=4;SUPP_CALLER=3;SUPP_CALLER_FORCE=2;MAX_RE=40;MEAN_VAF=0.978739;STD_VAF=0.0374884;MEAN_VAF_CALL=0.978739;STD_VAF_CALL=0.0374884 GT:DP:AD 1/1:.:.,. 22 16212542 All_method.DEL.1 CGCTCCAAATATCCACTCGCGGTTTCTGCAAAAAGAGTGTTTCAAAACTTCTCAATCAAAAGAAAGGTTCAACTCTGTGAGATGAATGCACACATCACAAAGAAGTTTCTCAGAATGCTTCTGTCTAGTTTTTATGTGAAGATATTCCCTTTTCCACCACAGGCC C . . SVTYPE=DEL;END=16212706;SVLEN=-164;AC=1;REPRESENT_SV=HG002.minimap2.svim.DEL.2;CIPOS_NGMLR_CUTESV=-4,4;CIPOS_MINIMAP2_CUTESV=-22,22;RE_NGMLR_CUTESV=2;RE_NGMLR_SNIFFLES=2;RE_MINIMAP2_CUTESV=46;RE_MINIMAP2_SNIFFLES=46;RE_MINIMAP2_SVIM=44;RE_NGMLR_SVIM=0;CILEN_NGMLR_CUTESV=-1,1;CILEN_MINIMAP2_CUTESV=-7,7;DP_NGMLR_CUTESV=3;DP_NGMLR_SNIFFLES=6;DP_MINIMAP2_CUTESV=66;DP_MINIMAP2_SNIFFLES=68;DP_MINIMAP2_SVIM=72;DP_NGMLR_SVIM=.;PRECISE_NGMLR_CUTESV;PRECISE_MINIMAP2_CUTESV;VAF_NGMLR_CUTESV=0.666667;VAF_NGMLR_SNIFFLES=0.333333;VAF_MINIMAP2_CUTESV=0.69697;VAF_MINIMAP2_SNIFFLES=0.676471;VAF_MINIMAP2_SVIM=0.611111;VAF_NGMLR_SVIM=0;SUPP_METHOD=5;SUPP_METHOD_FORCE=4;SUPP_CALLER=3;SUPP_CALLER_FORCE=2;MAX_RE=46;MEAN_VAF=0.497425;STD_VAF=0.254231;MEAN_VAF_CALL=0.59691;STD_VAF_CALL=0.13482 GT:DP:AD 0/1:.:.,.","title":"Examples"},{"location":"SV_analysis/genotype/#arguments","text":"","title":"Arguments"},{"location":"SV_analysis/genotype/#inputoutput-arguments","text":"-i, --invcf VCF input representative SV call set VCF/BCF -f, --manifest TSV tab separated manifest file of SV calling results. Column headers should be: file, sample, aligner, caller, is_force_call, info (optional) --sample ID sample to be genotyped, should be listed in the manifest file -o, --outvcf VCF output VCF -r, --region CHR region to genotype (requires indexed VCF)","title":"Input/Output arguments:"},{"location":"SV_analysis/genotype/#genotyping-arguments","text":"--min-dp 10 minimum depth to to genotype SVs as 0/0 if no method has VAF > --hetero-freq , otherwise ./. (default: 10) --homo-freq 0.8 minimum average variant allele fraction to genotype as homozygous (default: 0.8) --hetero-freq 0.2 minimum average variant allele fraction to genotype as heterozygous (default: 0.2) --include all methods to be included to determine genotype. Options: 'all', 'force_call', or comma-separated list of methods in format of 'ALIGNER_CALLER' (default: 'all')","title":"Genotyping arguments:"},{"location":"SV_analysis/represent/","text":"represent Select the representative SV from merged SVs Last updated: 2023-01-16 Input requirmenets VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , SVLEN , AC ID : unique ID across all input VCFs VCF file list : Format : one VCF/BCF per line SV merging results : Format : comma-separated list of merged SV IDs, unique SVs that are not merged with others should also be included without comma Region : Format : region string accepted by bcftools (e.g., chr1[:100-200] ) Output VCF : representative SV VCF/BCF files. INFO : REPRESENT_SV : original ID of the representative SV ID_LIST : list of SVs merged to the representative SV ID : {SVTYPE}.{NUMBER} by default. --id-prefix PREFIX will add {PREFIX}. to the beginning, --region STR will add {STR}_ before {NUMBER} . Usage harmonisv represent [options] -i <input_vcf> -o <output_vcf> --merge <merge_file> harmonisv represent [options] -f <file_list> -o <output_vcf> --merge <merge_file> Representative SV SV calling results can vary significantly across different methods or samples. Therefore, merging SVs across samples and methods is a common practice to identify non-redundant SVs. Once the SVs are merged, the position, length, and alleles of the merged SV can be determined based on the representative SV. The represent command is used to select the representative SV from the merged SVs using one of the following criteria: --by-max TAG : This option selects the SV with the maximum value of INFO/TAG . --by-freq : This option selects the SV with the maximum frequency of POS and SVLEN . If more than one SV has the same frequency, it selects the one closest to the average POS and SVLEN . Examples 1. Select representative SVs from SVs merged across samples and methods In this example, we will first use Jasmine to merge SVs across samples and methods, and then select the representative SV based on the prevalence of SVs' positions and lengths. # prepare VCF file list for vcf in SampleA.Method1.vcf SampleA.Method2.vcf SampleB.Method1.vcf SampleB.Method2.vcf; do echo ${vcf} done > vcf_list.txt # SV merging across samples and methods jasmine \\ file_list=vcf_list.txt \\ out_file=merged.vcf \\ --keep_var_ids \\ --ignore_strand # extract SV merging results bcftools query -f '%IDLIST\\n' merged.vcf > merge.txt # Select representative SV based on the frequency of POS and SVLEN harmonisv represent \\ -f vcf_list.txt \\ -o representative.vcf \\ --merge merge.txt \\ --by-freq \\ --id-prefix Merged \\ # rename output SV ID as Merged.SVTYPE.NUMBER --save-id \\ # save merged SVs to INFO/ID_LIST --min-len-input 35 \\ # only SVs with SVLEN < 35 are considered when selecting representative SV --min-len-output 50 # drop representative SVs with SVLEN < 50 2. Remove duplicated SVs within the same sample and method SV calling methods may produce duplicated SVs within the same sequencing data. This example will first use Jasmine to merge SVs within the same sample and method, and then select the representative SV based on the maximum value of reads supporting the SV. # SV merging within the same sample and method jasmine \\ file_list=input.vcf \\ out_file=jasmine.vcf \\ --comma_filelist \\ max_dist=200 \\ --allow_intrasample \\ --nonlinear_dist \\ --ignore_strand \\ --keep_var_ids # extract SV merging results bcftools query -f '%INTRASAMPLE_IDLIST\\n' jasmine.vcf > dup_sv.txt # Select representative SV based on the maximum value of reads supporting the SV (INFO/RE) harmonisv represent \\ -i input.vcf \\ -o dedup.vcf \\ --merge dup_sv.txt \\ --by-max RE \\ --min-len-input 30 \\ --min-len-output 30 Arguments Input/Output arguments: -i, --invcf VCF input VCF -f, --file-list TSV list of VCF files, one VCF per line -o, --outvcf VCF output VCF --merge FILE SV merging results, each line is a comma-separated list of IDs of merged SVs, or the ID of unique SVs -r, --region CHR genomic region to work on (requires VCF with index) Representative SV selection arguments: --id-prefix PREFIX Rename output SV ID as PREFIX.SVTYPE.NUMBER --by-max TAG Select representative SV by maximum INFO/TAG value --by-freq Select representative SV by frequency of POS, SVLEN, if >1 SVs have same frequency, select the one closest to average POS, SVLEN --save-id Save original IDs to INFO/ID_LIST --keep-hom-ref Keep SVs with AC=0 before selecting representative SV (Default: False) --min-len-input N Remove SVLEN < min_len_input before selecting representative SV (Default: 35) --min-len-output N Remove SVLEN < min_len_output from output (Default: 50)","title":"represent"},{"location":"SV_analysis/represent/#represent","text":"Select the representative SV from merged SVs Last updated: 2023-01-16","title":"represent"},{"location":"SV_analysis/represent/#input-requirmenets","text":"VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , SVLEN , AC ID : unique ID across all input VCFs VCF file list : Format : one VCF/BCF per line SV merging results : Format : comma-separated list of merged SV IDs, unique SVs that are not merged with others should also be included without comma Region : Format : region string accepted by bcftools (e.g., chr1[:100-200] )","title":"Input requirmenets"},{"location":"SV_analysis/represent/#output","text":"VCF : representative SV VCF/BCF files. INFO : REPRESENT_SV : original ID of the representative SV ID_LIST : list of SVs merged to the representative SV ID : {SVTYPE}.{NUMBER} by default. --id-prefix PREFIX will add {PREFIX}. to the beginning, --region STR will add {STR}_ before {NUMBER} .","title":"Output"},{"location":"SV_analysis/represent/#usage","text":"harmonisv represent [options] -i <input_vcf> -o <output_vcf> --merge <merge_file> harmonisv represent [options] -f <file_list> -o <output_vcf> --merge <merge_file>","title":"Usage"},{"location":"SV_analysis/represent/#representative-sv","text":"SV calling results can vary significantly across different methods or samples. Therefore, merging SVs across samples and methods is a common practice to identify non-redundant SVs. Once the SVs are merged, the position, length, and alleles of the merged SV can be determined based on the representative SV. The represent command is used to select the representative SV from the merged SVs using one of the following criteria: --by-max TAG : This option selects the SV with the maximum value of INFO/TAG . --by-freq : This option selects the SV with the maximum frequency of POS and SVLEN . If more than one SV has the same frequency, it selects the one closest to the average POS and SVLEN .","title":"Representative SV"},{"location":"SV_analysis/represent/#examples","text":"","title":"Examples"},{"location":"SV_analysis/represent/#1-select-representative-svs-from-svs-merged-across-samples-and-methods","text":"In this example, we will first use Jasmine to merge SVs across samples and methods, and then select the representative SV based on the prevalence of SVs' positions and lengths. # prepare VCF file list for vcf in SampleA.Method1.vcf SampleA.Method2.vcf SampleB.Method1.vcf SampleB.Method2.vcf; do echo ${vcf} done > vcf_list.txt # SV merging across samples and methods jasmine \\ file_list=vcf_list.txt \\ out_file=merged.vcf \\ --keep_var_ids \\ --ignore_strand # extract SV merging results bcftools query -f '%IDLIST\\n' merged.vcf > merge.txt # Select representative SV based on the frequency of POS and SVLEN harmonisv represent \\ -f vcf_list.txt \\ -o representative.vcf \\ --merge merge.txt \\ --by-freq \\ --id-prefix Merged \\ # rename output SV ID as Merged.SVTYPE.NUMBER --save-id \\ # save merged SVs to INFO/ID_LIST --min-len-input 35 \\ # only SVs with SVLEN < 35 are considered when selecting representative SV --min-len-output 50 # drop representative SVs with SVLEN < 50","title":"1. Select representative SVs from SVs merged across samples and methods"},{"location":"SV_analysis/represent/#2-remove-duplicated-svs-within-the-same-sample-and-method","text":"SV calling methods may produce duplicated SVs within the same sequencing data. This example will first use Jasmine to merge SVs within the same sample and method, and then select the representative SV based on the maximum value of reads supporting the SV. # SV merging within the same sample and method jasmine \\ file_list=input.vcf \\ out_file=jasmine.vcf \\ --comma_filelist \\ max_dist=200 \\ --allow_intrasample \\ --nonlinear_dist \\ --ignore_strand \\ --keep_var_ids # extract SV merging results bcftools query -f '%INTRASAMPLE_IDLIST\\n' jasmine.vcf > dup_sv.txt # Select representative SV based on the maximum value of reads supporting the SV (INFO/RE) harmonisv represent \\ -i input.vcf \\ -o dedup.vcf \\ --merge dup_sv.txt \\ --by-max RE \\ --min-len-input 30 \\ --min-len-output 30","title":"2. Remove duplicated SVs within the same sample and method"},{"location":"SV_analysis/represent/#arguments","text":"","title":"Arguments"},{"location":"SV_analysis/represent/#inputoutput-arguments","text":"-i, --invcf VCF input VCF -f, --file-list TSV list of VCF files, one VCF per line -o, --outvcf VCF output VCF --merge FILE SV merging results, each line is a comma-separated list of IDs of merged SVs, or the ID of unique SVs -r, --region CHR genomic region to work on (requires VCF with index)","title":"Input/Output arguments:"},{"location":"SV_analysis/represent/#representative-sv-selection-arguments","text":"--id-prefix PREFIX Rename output SV ID as PREFIX.SVTYPE.NUMBER --by-max TAG Select representative SV by maximum INFO/TAG value --by-freq Select representative SV by frequency of POS, SVLEN, if >1 SVs have same frequency, select the one closest to average POS, SVLEN --save-id Save original IDs to INFO/ID_LIST --keep-hom-ref Keep SVs with AC=0 before selecting representative SV (Default: False) --min-len-input N Remove SVLEN < min_len_input before selecting representative SV (Default: 35) --min-len-output N Remove SVLEN < min_len_output from output (Default: 50)","title":"Representative SV selection arguments:"},{"location":"VCF_manipulation/harmonize/","text":"harmonize Harmonize SV VCFs across samples and SV calling methods Last updated: 2023-12-08 Input requirmenets VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , if other name is used, specify by --svtype Output VCF : harmonized VCF/BCF files. ID : {PREFIX}.{SVTYPE}.{NUMBER} if --rename-id --id-prefix PREFIX is specified, otherwise the same as input. Usage harmonisv harmonize [options] -i <input_vcf> -o <output_vcf> Input filtering By default, the following records will be removed: Records with missing ID or duplicated ID if --rename-id is not specified Records without INFO/SVTYPE Records' INFO/SVTYPE not in \"INS, DEL, DUP, INV, CNV, BND\" If the types of SVs are stored in INFO field with different names, use --svtype to specify the tag name. If the SV types are not in the above list, use --INS , --DEL , --DUP , --INV , --CNV , --BND to normalize the SV types. For example, --info SVTYPE_raw=SVTYPE --DUP DUP,DUP:TANDEM will normalize SVTYPE=DUP:TANDEM to SVTYPE=DUP;SVTYPE_raw=DUP:TANDEM . To disable the check, use --no-check . VCF headers The VCF headers produced by different SV calling methods are usually not compatable. It is necessary to have a unified VCF header for downstream analysis. If only INFO tags from the original VCFs will be used, one simple method is to use harmonisv harmonize-header to combine the headers from all VCFs (see harmonize-header ). However, if any new INFO tags will be added / renamed, please use --header-str to specify them. For example, the following command will combine the headers of method A, B, and C, and add INFO/STRANDS header. harmonisv harmonize-header \\ -i A.vcf,B.vcf,C.vcf \\ -o harmonized_header.txt \\ for vcf in A.vcf B.vcf C.vcf; do harmonisv harmonize \\ -i $vcf \\ -o harmonized.$vcf \\ --header harmonized_header.txt \\ --header-str 'STRANDS,1,String,Strand orientation of supporting reads' done Examples In this example, we will rename variant ID, normalize SVTYPE, and extract the basic SV calling information: SVTYPE SVLEN END STRANDS (if exists) DP (sequencing depth) RE (number of reads supporting the SV) Please note that SV-calling methods may store this information under different names. For instance, INFO/SUPPORT might be used for RE , and FORMAT/DP for DP . The sequencing depth might also be provided separately for REF and ALT alleles (e.g., FORMAT/DR and FORMAT/DV ). Additionally, the same type of SV might have different names in different methods (e.g., DUP:TANDEM vs DUP ). All the harmonized information will be stored in the INFO field. Sniffles2 (ver 2.0.6) harmonisv harmonize \\ -i HG002.minimap2.sniffles.vcf \\ # input VCF -o HG002.minimap2.sniffles.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,STRANDS=STRAND \\ # INFO fields to be kept, rename STRAND to STRANDS --format-to-info RE=DV \\ # Extract FORMAT/DV to INFO/RE --format-to-info-sum DP=DR,DP=DV \\ # Calculate INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # Replace VCF header --id-prefix HG002.minimap2.sniffles \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID SVIM (ver 2.0.0) harmonisv harmonize \\ -i HG002.minimap2.svim.vcf \\ # input VCF -o HG002.minimap2.svim.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,RE=SUPPORT \\ # INFO fields to be kept, rename SUPPORT to RE --format-to-info DP=DP \\ # Extract FORMAT/DP to INFO/DP --DUP DUP,DUP:TANDEM,DUP:INT \\ # Normalize the name of duplications --header harmonized_header.txt \\ # Harmonized VCF header --id-prefix HG002.minimap2.svim \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID cuteSV (ver 2.0.3) harmonisv harmonize \\ -i HG002.minimap2.cuteSV.vcf \\ # input VCF -o HG002.minimap2.cuteSV.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,RE \\ # INFO fields to be kept --format-to-info-sum DP=DR,DP=DV \\ # Calculate INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # Harmonized VCF header --id-prefix HG002.minimap2.cuteSV \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID By default, all INFO tags not specified in --info will be removed. To keep all original INFO tags, use --keep-all . To keep the original INFO tags before renaming, use --keep-old . Meanwhile, allele count (AC) and allele number (AN) will also be automatically computed from genotypes. To disable this feature, use --no-AC . Particularly, harmonisv harmonize -i input.vcf -o output.vcf --keep-all --no-AC --no-check should produce the same variant records as the input (some VCF headers are still added). Arguments Input/Output arguments: -i, --invcf VCF input VCF -o, --outvcf VCF output VCF VCF INFO manipulation: --info TAG Comma separated INFO tags to extract or rename. INFO tags can be renamed by NEW=OLD, from high prioirty to low priority, e.g., 'NEW=OLD1,NEW=OLD2' means if OLD1 is present, use OLD1, otherwise use OLD2. --info-sum TAG Comma separated INFO tags to extract and sum. Old tags with the same new tag name will be summed up, e.g., 'NEW=OLD1,NEW=OLD2' means 'INFO/NEW = INFO/OLD1 + INFO/OLD2'. Please define the header of new tags in --header or --header-str --format-to-info TAG Comma separated FORMAT tags to sum across samples and add to INFO, from high prioirty to low priority, e.g., DP=DP means 'INFO/DP = sum(FORMAT/DP)'. --format-to-info-sum TAG Comma separated FORMAT tags to sum across samples and tags and add to INFO, e.g., 'DP=DR,DP=DV' means 'INFO/DP = sum(FORMAT/DR) + sum(FORMAT/DV)'. Please define the header of new tags in --header or --header-str --info-to-alt TAG Comma separated INFO tags to fill in ALT, from high prioirty to low priority. This is useful if insertion sequence stored in INFO. --keep-old Keep original INFO tags after renaming or sum (default: False) --keep-all Keep all original INFO tags (default: False) --no-AC Disable automatically add AC and AN to INFO (default: False) VCF header manipulation: --header FILE New VCF header file to replace the header of input VCF. --header-str string Semicolon separated INFO header string added to new header (metadata separated by comma), e.g., 'DP,1,Integar,Sequencing depth;AF,1,Float,Allele frequency' Structural variation format: --id-prefix PREFIX Rename SV ID to PREFIX.raw_ID. Final ID should be Sample.Aligner.Caller.unique_id for downstream analysis --rename-id Rename SV ID to PREFIX.SVTYPE.No., must use with --id-prefix --svtype SVTYPE INFO tag stores the structural variation type (default: SVTYPE), will rename it to SVTYPE if not. --INS INS Comma separated SVTYPE string for insertions, will be nomalized as INS (default: INS) --DEL DEL Comma separated SVTYPE string for deletions, will be nomalized as DEL (default: DEL) --DUP DUP Comma separated SVTYPE string for duplications, will be nomalized as DUP (default: DUP) --INV INV Comma separated SVTYPE string for inversions, will be nomalized as INV (default: INV) --CNV CNV Comma separated SVTYPE string for copy number variations, will be nomalized as CNV (default: CNV) --BND BND Comma separated SVTYPE string for breakends, will be nomalized as BND (default: BND) --no-check Disable check and filter on variant ID and SVTYPE (default: False)","title":"harmonize"},{"location":"VCF_manipulation/harmonize/#harmonize","text":"Harmonize SV VCFs across samples and SV calling methods Last updated: 2023-12-08","title":"harmonize"},{"location":"VCF_manipulation/harmonize/#input-requirmenets","text":"VCF : Format : bi-allelic VCF/BCF files following the VCF specification INFO : SVTYPE , if other name is used, specify by --svtype","title":"Input requirmenets"},{"location":"VCF_manipulation/harmonize/#output","text":"VCF : harmonized VCF/BCF files. ID : {PREFIX}.{SVTYPE}.{NUMBER} if --rename-id --id-prefix PREFIX is specified, otherwise the same as input.","title":"Output"},{"location":"VCF_manipulation/harmonize/#usage","text":"harmonisv harmonize [options] -i <input_vcf> -o <output_vcf>","title":"Usage"},{"location":"VCF_manipulation/harmonize/#input-filtering","text":"By default, the following records will be removed: Records with missing ID or duplicated ID if --rename-id is not specified Records without INFO/SVTYPE Records' INFO/SVTYPE not in \"INS, DEL, DUP, INV, CNV, BND\" If the types of SVs are stored in INFO field with different names, use --svtype to specify the tag name. If the SV types are not in the above list, use --INS , --DEL , --DUP , --INV , --CNV , --BND to normalize the SV types. For example, --info SVTYPE_raw=SVTYPE --DUP DUP,DUP:TANDEM will normalize SVTYPE=DUP:TANDEM to SVTYPE=DUP;SVTYPE_raw=DUP:TANDEM . To disable the check, use --no-check .","title":"Input filtering"},{"location":"VCF_manipulation/harmonize/#vcf-headers","text":"The VCF headers produced by different SV calling methods are usually not compatable. It is necessary to have a unified VCF header for downstream analysis. If only INFO tags from the original VCFs will be used, one simple method is to use harmonisv harmonize-header to combine the headers from all VCFs (see harmonize-header ). However, if any new INFO tags will be added / renamed, please use --header-str to specify them. For example, the following command will combine the headers of method A, B, and C, and add INFO/STRANDS header. harmonisv harmonize-header \\ -i A.vcf,B.vcf,C.vcf \\ -o harmonized_header.txt \\ for vcf in A.vcf B.vcf C.vcf; do harmonisv harmonize \\ -i $vcf \\ -o harmonized.$vcf \\ --header harmonized_header.txt \\ --header-str 'STRANDS,1,String,Strand orientation of supporting reads' done","title":"VCF headers"},{"location":"VCF_manipulation/harmonize/#examples","text":"In this example, we will rename variant ID, normalize SVTYPE, and extract the basic SV calling information: SVTYPE SVLEN END STRANDS (if exists) DP (sequencing depth) RE (number of reads supporting the SV) Please note that SV-calling methods may store this information under different names. For instance, INFO/SUPPORT might be used for RE , and FORMAT/DP for DP . The sequencing depth might also be provided separately for REF and ALT alleles (e.g., FORMAT/DR and FORMAT/DV ). Additionally, the same type of SV might have different names in different methods (e.g., DUP:TANDEM vs DUP ). All the harmonized information will be stored in the INFO field. Sniffles2 (ver 2.0.6) harmonisv harmonize \\ -i HG002.minimap2.sniffles.vcf \\ # input VCF -o HG002.minimap2.sniffles.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,STRANDS=STRAND \\ # INFO fields to be kept, rename STRAND to STRANDS --format-to-info RE=DV \\ # Extract FORMAT/DV to INFO/RE --format-to-info-sum DP=DR,DP=DV \\ # Calculate INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # Replace VCF header --id-prefix HG002.minimap2.sniffles \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID SVIM (ver 2.0.0) harmonisv harmonize \\ -i HG002.minimap2.svim.vcf \\ # input VCF -o HG002.minimap2.svim.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,RE=SUPPORT \\ # INFO fields to be kept, rename SUPPORT to RE --format-to-info DP=DP \\ # Extract FORMAT/DP to INFO/DP --DUP DUP,DUP:TANDEM,DUP:INT \\ # Normalize the name of duplications --header harmonized_header.txt \\ # Harmonized VCF header --id-prefix HG002.minimap2.svim \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID cuteSV (ver 2.0.3) harmonisv harmonize \\ -i HG002.minimap2.cuteSV.vcf \\ # input VCF -o HG002.minimap2.cuteSV.harmonized.vcf \\ # output VCF --info SVTYPE,SVLEN,END,RE \\ # INFO fields to be kept --format-to-info-sum DP=DR,DP=DV \\ # Calculate INFO/DP = FORMAT/DR + FORMAT/DV --header harmonized_header.txt \\ # Harmonized VCF header --id-prefix HG002.minimap2.cuteSV \\ # {SAMPLE}.{ALIGNER}.{CALLER} --rename-id # Rename all variant ID By default, all INFO tags not specified in --info will be removed. To keep all original INFO tags, use --keep-all . To keep the original INFO tags before renaming, use --keep-old . Meanwhile, allele count (AC) and allele number (AN) will also be automatically computed from genotypes. To disable this feature, use --no-AC . Particularly, harmonisv harmonize -i input.vcf -o output.vcf --keep-all --no-AC --no-check should produce the same variant records as the input (some VCF headers are still added).","title":"Examples"},{"location":"VCF_manipulation/harmonize/#arguments","text":"","title":"Arguments"},{"location":"VCF_manipulation/harmonize/#inputoutput-arguments","text":"-i, --invcf VCF input VCF -o, --outvcf VCF output VCF","title":"Input/Output arguments:"},{"location":"VCF_manipulation/harmonize/#vcf-info-manipulation","text":"--info TAG Comma separated INFO tags to extract or rename. INFO tags can be renamed by NEW=OLD, from high prioirty to low priority, e.g., 'NEW=OLD1,NEW=OLD2' means if OLD1 is present, use OLD1, otherwise use OLD2. --info-sum TAG Comma separated INFO tags to extract and sum. Old tags with the same new tag name will be summed up, e.g., 'NEW=OLD1,NEW=OLD2' means 'INFO/NEW = INFO/OLD1 + INFO/OLD2'. Please define the header of new tags in --header or --header-str --format-to-info TAG Comma separated FORMAT tags to sum across samples and add to INFO, from high prioirty to low priority, e.g., DP=DP means 'INFO/DP = sum(FORMAT/DP)'. --format-to-info-sum TAG Comma separated FORMAT tags to sum across samples and tags and add to INFO, e.g., 'DP=DR,DP=DV' means 'INFO/DP = sum(FORMAT/DR) + sum(FORMAT/DV)'. Please define the header of new tags in --header or --header-str --info-to-alt TAG Comma separated INFO tags to fill in ALT, from high prioirty to low priority. This is useful if insertion sequence stored in INFO. --keep-old Keep original INFO tags after renaming or sum (default: False) --keep-all Keep all original INFO tags (default: False) --no-AC Disable automatically add AC and AN to INFO (default: False)","title":"VCF INFO manipulation:"},{"location":"VCF_manipulation/harmonize/#vcf-header-manipulation","text":"--header FILE New VCF header file to replace the header of input VCF. --header-str string Semicolon separated INFO header string added to new header (metadata separated by comma), e.g., 'DP,1,Integar,Sequencing depth;AF,1,Float,Allele frequency'","title":"VCF header manipulation:"},{"location":"VCF_manipulation/harmonize/#structural-variation-format","text":"--id-prefix PREFIX Rename SV ID to PREFIX.raw_ID. Final ID should be Sample.Aligner.Caller.unique_id for downstream analysis --rename-id Rename SV ID to PREFIX.SVTYPE.No., must use with --id-prefix --svtype SVTYPE INFO tag stores the structural variation type (default: SVTYPE), will rename it to SVTYPE if not. --INS INS Comma separated SVTYPE string for insertions, will be nomalized as INS (default: INS) --DEL DEL Comma separated SVTYPE string for deletions, will be nomalized as DEL (default: DEL) --DUP DUP Comma separated SVTYPE string for duplications, will be nomalized as DUP (default: DUP) --INV INV Comma separated SVTYPE string for inversions, will be nomalized as INV (default: INV) --CNV CNV Comma separated SVTYPE string for copy number variations, will be nomalized as CNV (default: CNV) --BND BND Comma separated SVTYPE string for breakends, will be nomalized as BND (default: BND) --no-check Disable check and filter on variant ID and SVTYPE (default: False)","title":"Structural variation format:"},{"location":"VCF_manipulation/harmonize_header/","text":"harmonize-header Harmonize VCF headers Last updated: 2023-12-08 Input requirmenets VCF : VCF/BCF files following the VCF specification. Output VCF header : harmonized VCF header containing all header records of input VCFs Usage harmonisv harmonize-header [options] -i <input_vcf> -o <output_header> Examples In this example, the VCF headers from cuteSV, sniffles, and svim are harmonized. If one header occurs in more than one VCF, the priority is: sniffles > cuteSV > svim (based on the input order). harmonisv harmonize-header \\ -i HG002.minimap2.cuteSV.vcf,HG002.minimap2.sniffles.vcf,HG002.minimap2.svim.vcf \\ -o harmonized_header.txt \\ -r HG002.minimap2.sniffles.vcf # reference VCF has the highest priority Input: HG002.minimap2.cuteSV.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Precise structural variant\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Imprecise structural variant\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Difference in length between REF and ALT alleles\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT NULL HG002.minimap2.sniffles.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Structural variation with precise breakpoints\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Structural variation with imprecise breakpoints\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of structural variation\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variation\"> ##INFO=<ID=STDEV_POS,Number=1,Type=Float,Description=\"Standard deviation of structural variation start position\"> ##INFO=<ID=STDEV_LEN,Number=1,Type=Float,Description=\"Standard deviation of structural variation length\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE HG002.minimap2.svim.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Difference in length between REF and ALT alleles\"> ##INFO=<ID=STD_SPAN,Number=1,Type=Float,Description=\"Standard deviation in span of merged SV signatures\"> ##INFO=<ID=STD_POS,Number=1,Type=Float,Description=\"Standard deviation in position of merged SV signatures\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT Sample Output: PRECISE , IMPRECISE , SVLEN , SVTYPE are defined in multiple VCFs, and the output use the definition in sniffles as it has the highest priority. STDEV_POS , STDEV_LEN , STD_SPAN , STD_POS are defined in single VCF and are appended to the output header. ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Structural variation with precise breakpoints\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Structural variation with imprecise breakpoints\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of structural variation\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variation\"> ##INFO=<ID=STDEV_POS,Number=1,Type=Float,Description=\"Standard deviation of structural variation start position\"> ##INFO=<ID=STDEV_LEN,Number=1,Type=Float,Description=\"Standard deviation of structural variation length\"> ##INFO=<ID=STD_SPAN,Number=1,Type=Float,Description=\"Standard deviation in span of merged SV signatures\"> ##INFO=<ID=STD_POS,Number=1,Type=Float,Description=\"Standard deviation in position of merged SV signatures\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE Arguments Input/Output arguments: -i, --invcf VCF Comma-separated list of input VCF files. Duplicate headers will use the first one, including SAMPLE header. For multi-sample VCF, please make sure all input VCFs have the same SAMPLE order. -f, --file-list FILE_LIST File containing a list of input VCF files, one VCF per line. VCFs from both -i and -f will be used. -o, --output OUTPUT Output VCF header file optional arguments: -r, --ref-vcf VCF Reference VCF file, highest priority for duplicated headers","title":"harmonize-header"},{"location":"VCF_manipulation/harmonize_header/#harmonize-header","text":"Harmonize VCF headers Last updated: 2023-12-08","title":"harmonize-header"},{"location":"VCF_manipulation/harmonize_header/#input-requirmenets","text":"VCF : VCF/BCF files following the VCF specification.","title":"Input requirmenets"},{"location":"VCF_manipulation/harmonize_header/#output","text":"VCF header : harmonized VCF header containing all header records of input VCFs","title":"Output"},{"location":"VCF_manipulation/harmonize_header/#usage","text":"harmonisv harmonize-header [options] -i <input_vcf> -o <output_header>","title":"Usage"},{"location":"VCF_manipulation/harmonize_header/#examples","text":"In this example, the VCF headers from cuteSV, sniffles, and svim are harmonized. If one header occurs in more than one VCF, the priority is: sniffles > cuteSV > svim (based on the input order). harmonisv harmonize-header \\ -i HG002.minimap2.cuteSV.vcf,HG002.minimap2.sniffles.vcf,HG002.minimap2.svim.vcf \\ -o harmonized_header.txt \\ -r HG002.minimap2.sniffles.vcf # reference VCF has the highest priority Input: HG002.minimap2.cuteSV.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Precise structural variant\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Imprecise structural variant\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Difference in length between REF and ALT alleles\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT NULL HG002.minimap2.sniffles.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Structural variation with precise breakpoints\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Structural variation with imprecise breakpoints\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of structural variation\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variation\"> ##INFO=<ID=STDEV_POS,Number=1,Type=Float,Description=\"Standard deviation of structural variation start position\"> ##INFO=<ID=STDEV_LEN,Number=1,Type=Float,Description=\"Standard deviation of structural variation length\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE HG002.minimap2.svim.vcf: ##fileformat=VCFv4.2 ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Difference in length between REF and ALT alleles\"> ##INFO=<ID=STD_SPAN,Number=1,Type=Float,Description=\"Standard deviation in span of merged SV signatures\"> ##INFO=<ID=STD_POS,Number=1,Type=Float,Description=\"Standard deviation in position of merged SV signatures\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT Sample Output: PRECISE , IMPRECISE , SVLEN , SVTYPE are defined in multiple VCFs, and the output use the definition in sniffles as it has the highest priority. STDEV_POS , STDEV_LEN , STD_SPAN , STD_POS are defined in single VCF and are appended to the output header. ##fileformat=VCFv4.2 ##INFO=<ID=PRECISE,Number=0,Type=Flag,Description=\"Structural variation with precise breakpoints\"> ##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Structural variation with imprecise breakpoints\"> ##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of structural variation\"> ##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variation\"> ##INFO=<ID=STDEV_POS,Number=1,Type=Float,Description=\"Standard deviation of structural variation start position\"> ##INFO=<ID=STDEV_LEN,Number=1,Type=Float,Description=\"Standard deviation of structural variation length\"> ##INFO=<ID=STD_SPAN,Number=1,Type=Float,Description=\"Standard deviation in span of merged SV signatures\"> ##INFO=<ID=STD_POS,Number=1,Type=Float,Description=\"Standard deviation in position of merged SV signatures\"> #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE","title":"Examples"},{"location":"VCF_manipulation/harmonize_header/#arguments","text":"","title":"Arguments"},{"location":"VCF_manipulation/harmonize_header/#inputoutput-arguments","text":"-i, --invcf VCF Comma-separated list of input VCF files. Duplicate headers will use the first one, including SAMPLE header. For multi-sample VCF, please make sure all input VCFs have the same SAMPLE order. -f, --file-list FILE_LIST File containing a list of input VCF files, one VCF per line. VCFs from both -i and -f will be used. -o, --output OUTPUT Output VCF header file","title":"Input/Output arguments:"},{"location":"VCF_manipulation/harmonize_header/#optional-arguments","text":"-r, --ref-vcf VCF Reference VCF file, highest priority for duplicated headers","title":"optional arguments:"}]}